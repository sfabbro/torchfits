#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
EXTERN_DIR="${ROOT_DIR}/extern"
TMP_DIR="${ROOT_DIR}/.tmp-vendor"

CFITSIO_REPO="HEASARC/cfitsio"
WCSLIB_INDEX_URL="http://www.atnf.csiro.au/people/Mark.Calabretta/WCS/"
WCSLIB_RELEASES_BASE_URL="http://www.atnf.csiro.au/people/Mark.Calabretta/WCS/wcslib-releases"
CFITSIO_VERSION="latest"
WCSLIB_VERSION="latest"

usage() {
  cat <<USAGE
Usage: $(basename "$0") [--cfitsio-version <tag>] [--wcslib-version <tag>]

Defaults to latest published release for each dependency.
Examples:
  $(basename "$0")
  $(basename "$0") --cfitsio-version cfitsio-4.6.2 --wcslib-version 8.5
USAGE
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --cfitsio-version)
      CFITSIO_VERSION="$2"
      shift 2
      ;;
    --wcslib-version)
      WCSLIB_VERSION="$2"
      shift 2
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "Unknown argument: $1" >&2
      usage
      exit 1
      ;;
  esac
done

require_cmd() {
  if ! command -v "$1" >/dev/null 2>&1; then
    echo "Missing required command: $1" >&2
    exit 1
  fi
}

require_cmd curl
require_cmd tar

latest_tag() {
  local repo="$1"
  local tag

  tag="$(curl -fsSL "https://api.github.com/repos/${repo}/releases/latest" \
    | sed -n 's/.*"tag_name"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' \
    | head -n1)"

  if [[ -z "${tag}" ]]; then
    tag="$(curl -fsSL "https://api.github.com/repos/${repo}/tags" \
      | sed -n 's/.*"name"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' \
      | head -n1)"
  fi

  if [[ -z "${tag}" ]]; then
    echo "Failed to resolve latest tag for ${repo}" >&2
    exit 1
  fi

  echo "${tag}"
}

latest_wcslib_version() {
  local version
  version="$(curl -fsSL "${WCSLIB_INDEX_URL}" \
    | sed -n 's/.*wcslib-releases\/wcslib-\([0-9.][0-9.]*\)\.tar\.bz2.*/\1/p' \
    | awk -F. '{printf "%d %d %d %s\n", $1, $2, $3, $0}' \
    | sort -n -k1,1 -k2,2 -k3,3 \
    | awk 'END {print $4}')"

  if [[ -z "${version}" ]]; then
    echo "Failed to resolve latest WCSLIB version from ${WCSLIB_INDEX_URL}" >&2
    exit 1
  fi

  echo "${version}"
}

fetch_and_extract() {
  local repo="$1"
  local tag="$2"
  local dest="$3"
  local archive="${TMP_DIR}/$(basename "${dest}")-${tag}.tar.gz"

  rm -rf "${dest}"
  mkdir -p "${TMP_DIR}"

  echo "Downloading ${repo}@${tag}"
  curl -fL "https://github.com/${repo}/archive/refs/tags/${tag}.tar.gz" -o "${archive}"

  local extract_dir="${TMP_DIR}/extract-$(basename "${dest}")-${tag}"
  rm -rf "${extract_dir}"
  mkdir -p "${extract_dir}"

  tar -xzf "${archive}" -C "${extract_dir}"
  local src_dir
  src_dir="$(find "${extract_dir}" -mindepth 1 -maxdepth 1 -type d | head -n1)"

  if [[ -z "${src_dir}" ]]; then
    echo "Failed to extract ${repo}@${tag}" >&2
    exit 1
  fi

  mv "${src_dir}" "${dest}"
}

write_wcslib_wrapper() {
  local cmake_file="${EXTERN_DIR}/wcslib/CMakeLists.txt"

  cat > "${cmake_file}" <<'CMAKE'
# CMake wrapper for vendored wcslib in torchfits.
cmake_minimum_required(VERSION 3.15)
project(wcslib_vendor LANGUAGES C)

set(WCSLIB_SOURCES
    C/cel.c
    C/dis.c
    C/getwcstab.c
    C/lin.c
    C/log.c
    C/prj.c
    C/spc.c
    C/spx.c
    C/sph.c
    C/tab.c
    C/wcs.c
    C/wcserr.c
    C/wcsfix.c
    C/wcshdr.c
    C/wcsprintf.c
    C/wcstrig.c
    C/wcsunits.c
    C/wcsutil.c
    C/flexed/fitshdr.c
    C/flexed/wcsbth.c
    C/flexed/wcspih.c
    C/flexed/wcsulex.c
    C/flexed/wcsutrn.c
)

add_library(wcs STATIC ${WCSLIB_SOURCES})
target_include_directories(wcs PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/C)
if(DEFINED CFITSIO_INCLUDE_DIR AND NOT "${CFITSIO_INCLUDE_DIR}" STREQUAL "")
    target_include_directories(wcs PRIVATE ${CFITSIO_INCLUDE_DIR})
endif()
if(DEFINED CFITSIO_INCLUDE_DIRS AND NOT "${CFITSIO_INCLUDE_DIRS}" STREQUAL "")
    target_include_directories(wcs PRIVATE ${CFITSIO_INCLUDE_DIRS})
endif()

if(NOT WIN32)
    target_link_libraries(wcs PRIVATE m)
endif()

set_target_properties(wcs PROPERTIES POSITION_INDEPENDENT_CODE ON)
CMAKE
}

write_wcslib_config_header() {
  local config_file="${EXTERN_DIR}/wcslib/C/wcsconfig.h"

  cat > "${config_file}" <<CONFIG
/* Auto-generated by extern/vendor.sh for vendored wcslib builds. */
#define HAVE_WCSLIB_VERSION
#define WCSLIB_VERSION ${WCSLIB_VERSION}
#define WCSLIB_INT64 long long int
CONFIG
}

if [[ "${CFITSIO_VERSION}" == "latest" ]]; then
  CFITSIO_VERSION="$(latest_tag "${CFITSIO_REPO}")"
fi

mkdir -p "${EXTERN_DIR}"
fetch_and_extract "${CFITSIO_REPO}" "${CFITSIO_VERSION}" "${EXTERN_DIR}/cfitsio"

# WCSLIB logic: resolve latest from official WCS release index and fetch tarball.
if [[ "${WCSLIB_VERSION}" == "latest" ]]; then
  WCSLIB_VERSION="$(latest_wcslib_version)"
fi

WCSLIB_URL="${WCSLIB_RELEASES_BASE_URL}/wcslib-${WCSLIB_VERSION}.tar.bz2"
echo "Downloading WCSLIB ${WCSLIB_VERSION} from ${WCSLIB_URL}"

# Custom fetch for WCSLIB
run_wcslib_fetch() {
    local dest="${EXTERN_DIR}/wcslib"
    local archive="${TMP_DIR}/wcslib-${WCSLIB_VERSION}.tar.bz2"
    
    rm -rf "${dest}"
    mkdir -p "${TMP_DIR}"
    
    curl -fL "${WCSLIB_URL}" -o "${archive}"
    
    local extract_dir="${TMP_DIR}/extract-wcslib-${WCSLIB_VERSION}"
    rm -rf "${extract_dir}"
    mkdir -p "${extract_dir}"
    
    tar -xjf "${archive}" -C "${extract_dir}"
    
    local src_dir
    src_dir="$(find "${extract_dir}" -mindepth 1 -maxdepth 1 -type d | head -n1)"
    
    if [[ -z "${src_dir}" ]]; then
      echo "Failed to extract wcslib" >&2
      exit 1
    fi
    
    mv "${src_dir}" "${dest}"
}

run_wcslib_fetch
write_wcslib_wrapper
write_wcslib_config_header

cat > "${EXTERN_DIR}/VERSIONS.txt" <<VERSIONS
cfitsio_repo=${CFITSIO_REPO}
cfitsio_tag=${CFITSIO_VERSION}
wcslib_source=${WCSLIB_RELEASES_BASE_URL}
wcslib_tag=${WCSLIB_VERSION}
VERSIONS

echo "Vendored deps prepared in ${EXTERN_DIR}"
echo "Recorded versions in ${EXTERN_DIR}/VERSIONS.txt"
